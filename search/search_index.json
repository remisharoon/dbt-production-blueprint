{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"dbt Production Blueprint","text":"<p>Welcome to the dbt Production Blueprint documentation site.</p> <p></p>"},{"location":"index.html#overview","title":"Overview","text":"<p><code>dbt-production-blueprint</code> is an enterprise-grade, Snowflake-focused dbt project that serves as a comprehensive reference implementation for real-world data warehousing. It includes layered modeling patterns, incremental processing, SCD Type 2 snapshots, dynamic SQL generation, testing, and operational hooks.</p> <p>Use this site to explore the architecture, data modeling conventions, and the embedded dbt documentation (DAG, lineage, and column-level metadata).</p>"},{"location":"architecture.html","title":"Project Architecture","text":"<p>This repository is intentionally designed as a \"kitchen sink\" for production-grade dbt patterns on Snowflake. The goal is to demonstrate how enterprise teams structure, document, test, and operate dbt projects at scale.</p>"},{"location":"architecture.html#layered-model-architecture","title":"Layered Model Architecture","text":"<p>Staging (<code>models/staging</code>): Raw sources are standardized, typed, and lightly cleaned. Surrogate keys are generated and raw columns are preserved where useful.</p> <p>Intermediate (<code>models/intermediate</code>): Business logic is normalized and reusable. Complex joins, rollups, and status categorization are implemented once and reused in marts.</p> <p>Marts (<code>models/marts/core</code>, <code>models/marts/finance</code>): Final, consumer-facing models optimized for analytics, reporting, and data products. Core marts contain dimensions and facts; finance marts contain revenue aggregates.</p>"},{"location":"architecture.html#incremental-processing","title":"Incremental Processing","text":"<p><code>fct_orders</code> is an incremental model using a merge strategy keyed by <code>order_id</code>, with updates filtered by <code>updated_at</code>. Soft-deleted records are tracked using <code>is_deleted</code>, <code>deleted_at</code>, and <code>net_order_total</code> to preserve history without inflating revenue.</p>"},{"location":"architecture.html#scd-type-2-snapshots","title":"SCD Type 2 (Snapshots)","text":"<p><code>snap_customers_history</code> tracks customer changes over time using the <code>timestamp</code> strategy on <code>updated_at</code>. This produces a full change history while preserving the current state in <code>dim_customers</code>.</p>"},{"location":"architecture.html#dynamic-sql-generation","title":"Dynamic SQL Generation","text":"<p>Macros generate SQL dynamically to support patterns like region-level rollups without hand-writing repetitive queries. This is used for the <code>region_summary</code> model in the finance mart.</p>"},{"location":"architecture.html#testing-quality","title":"Testing &amp; Quality","text":"<p>The project uses built-in dbt tests (<code>not_null</code>, <code>unique</code>, <code>relationships</code>), <code>dbt_expectations</code> for numeric and range checks, custom generic tests for ID validation, and cross-mart reconciliation tests for revenue consistency.</p>"},{"location":"architecture.html#documentation-exposures","title":"Documentation &amp; Exposures","text":"<p>Column-level documentation is enforced using dbt contracts. Doc blocks define metrics like Total Revenue and LTV. Exposures document key dashboards and applications that depend on models.</p>"}]}